# PhysiSim (物理场景模拟器)

## 项目简介

PhysiSim 是一款专为二维物理场景创建、模拟与交互而设计的开源软件。本项目致力于为广泛的用户群体，包括对物理学充满好奇的中学生和大学生、寻求直观教学辅助工具的物理教师、希望验证物理概念或进行虚拟实验的爱好者，以及对游戏物理引擎实现感兴趣的独立开发者和学习者，提供一个强大且易于上手的平台。

通过 PhysiSim，用户可以：
*   **直观构建物理世界**：使用内置的图形工具轻松创建各种形状的物体，并设置其物理属性。
*   **探索物理规律**：观察物体在重力、弹力、摩擦力等多种力作用下的运动轨迹和相互作用。
*   **进行虚拟实验**：模拟经典的物理实验场景，如碰撞、抛体运动、振动、连接体运动等，并通过调整参数观察结果变化。
*   **理解复杂概念**：通过可视化的方式加深对抽象物理概念（如约束动力学、碰撞响应、受力分析）的理解。
*   **学习与参考**：对于开发者而言，本项目的源码可以作为学习实体组件系统（ECS）、物理引擎实现（特别是碰撞检测与约束处理）以及GUI应用开发的参考。

## 核心特性

PhysiSim 提供了一系列强大的功能，旨在为用户带来流畅和富有深度的物理模拟体验：

### 1. 图形化场景构建

*   **多样化的形状工具**：
    *   **矩形 (Rectangle)**：通过拖拽快速定义矩形的尺寸和位置。
    *   **圆形 (Circle)**：通过指定圆心和半径创建圆形。
    *   **自定义多边形 (Custom Polygon)**：通过依次点击定义顶点，创建任意形状的凸多边形或凹多边形。
*   **直观的交互方式**：
    *   大部分形状的创建和编辑均支持鼠标直接在画布上操作。
    *   工具栏提供清晰的工具选择，方便在不同创建/编辑模式间切换。
    *   属性面板实时显示并允许修改选中对象的几何参数（如位置、旋转、尺寸）和物理参数。

### 2. 实体组件系统 (ECS) 架构

*   **架构概述**：项目采用现代游戏开发中流行的实体组件系统 (ECS) 架构。
    *   **实体 (Entity)**：场景中的基本单元，本身不包含数据或逻辑，仅作为组件的容器和唯一标识。
    *   **组件 (Component)**：存储实体特定方面的数据（例如，`TransformComponent` 存储位置和旋转，`PhysicsComponent` 存储质量、速度、受力等）。组件是纯数据结构。
    *   **系统 (System)**：处理具有特定组件组合的实体的逻辑和行为（例如，`PhysicsSystem` 更新具有物理组件的实体的位置和速度，`RendererSystem` 绘制具有可见组件的实体）。
*   **主要优势**：
    *   **解耦**：数据和逻辑分离，使得代码更易于理解、维护和测试。
    *   **灵活性与可扩展性**：方便添加新的组件类型和系统来扩展功能，而无需修改现有代码。
    *   **性能**：数据以更友好的方式组织，便于缓存优化和并行处理（尽管当前版本可能未完全利用并行性）。
    *   **数据驱动**：设计上更易于实现数据驱动的场景和行为。

### 3. 物理模拟核心

*   **动力学模拟**：
    *   基于牛顿第二定律 (`F=ma`) 计算物体的加速度。
    *   采用精确的数值积分方法（如 Verlet 积分或类似的辛积分器，具体实现可查阅 [`PhysicsSystem`](physi_sim/physics/physics_system.py:1)）来更新物体的位置和速度，以保证模拟的稳定性和能量守恒性。
*   **碰撞检测与处理**：
    *   **精确的碰撞检测**：
        *   主要使用**分离轴定理 (SAT - Separating Axis Theorem)** 来检测多边形之间的碰撞。SAT通过检查是否存在一条轴使得两个形状在该轴上的投影不重叠，来判断它们是否分离。
        *   对于圆形等其他形状，也实现了相应的精确检测算法。
    *   **碰撞响应与接触力**：
        *   一旦检测到碰撞，系统会计算碰撞点、碰撞法线和穿透深度。
        *   通过基于冲量 (Impulse-based) 的方法或计算接触力来处理碰撞响应，确保物体在碰撞后表现出符合物理规律的行为（如反弹、停止）。这涉及到摩擦力和恢复系数（弹性）的应用。具体实现在 [`CollisionSystem`](physi_sim/physics/collision_system.py:1) 和相关的求解器模块。

### 4. 连接器与约束动力学

*   **多种连接器类型**：
    *   **弹簧 (Spring)**：模拟胡克定律 (`F = -kx`)，连接两个实体或实体与固定点，产生与形变量成正比的恢复力。
    *   **轻杆 (Rod)**：连接两个实体，保持它们之间的距离固定。
    *   **轻绳 (Rope)**：连接两个实体，当它们之间的距离超过绳长时产生拉力，表现为单边约束。
*   **约束动力学处理**：
    *   连接器本质上是对系统施加了运动学约束。
    *   项目通过专门的约束求解器 (如 [`ConstraintSolver`](physi_sim/physics/constraint_solver.py:1) 或相关系统如 [`SpringSystem`](physi_sim/physics/spring_system.py:1), [`RopeSystem`](physi_sim/physics/rope_system.py:1)) 来处理这些约束。
    *   这通常涉及到迭代求解或更高级的约束力计算方法（如基于拉格朗日乘子法的思想，即使实现上可能简化），以确保所有约束条件在每个模拟步骤中都得到满足。

### 5. 高级GUI交互

*   **实体选择与操作**：
    *   **单击选择**：选中单个实体。
    *   **多选**：按住 `Ctrl` (或 `Cmd` on macOS) 点击可添加/移除选中实体；按住 `Shift` 可进行范围选择（如果实现）。
    *   **框选**：在选择工具下，通过拖拽鼠标形成选择框，选中框内所有实体。
    *   **按类型选择**：提供便捷方式（可能通过菜单或快捷键）一次性选择场景中所有特定类型的实体（例如，所有圆形物体）。
*   **属性面板 (Property Panel)**：
    *   选中一个或多个实体后，属性面板 ([`PropertyPanel`](physi_sim/graphics/property_panel.py:1)) 会动态显示其共享的或单独的属性。
    *   可编辑的关键属性包括：位置、旋转角度、线速度、角速度、质量、惯性矩（若适用）、摩擦系数、恢复系数、颜色、是否固定等。
    *   对于连接器，可编辑弹簧的劲度系数、原长，轻杆的长度等。
*   **拖拽与变换**：
    *   使用选择工具，可以直接拖拽实体来改变其位置。
    *   可能提供旋转手柄或通过属性面板修改旋转角度。
*   **工具切换系统**：
    *   主窗口 ([`MainWindow`](physi_sim/graphics/main_window.py:1)) 包含一个工具栏，允许用户在不同的操作模式间切换。
    *   每个工具 (如 [`RectangleToolHandler`](physi_sim/graphics/drawing_tools/rectangle_tool_handler.py:1), [`SelectToolHandler`](physi_sim/graphics/drawing_tools/select_tool_handler.py:1), [`SpringToolHandler`](physi_sim/graphics/drawing_tools/spring_tool_handler.py:1) 等) 都有其特定的鼠标事件处理逻辑。
*   **视图控制 (View Control)**：
    *   **平移 (Pan)**：通过专用工具或快捷键（如按住鼠标中键拖拽）移动画布的可视区域。
    *   **缩放 (Zoom)**：通过鼠标滚轮或专用按钮进行视图的放大和缩小，通常以鼠标指针位置为缩放中心。
    *   **重置视图/聚焦**：提供将视图恢复到默认状态或聚焦到整个场景/选中实体的功能。
*   **时间控制 (Simulation Control)**：
    *   **播放/暂停**：控制物理模拟的启动和暂停。
    *   **单步执行**：允许用户逐帧观察模拟过程，便于调试和分析。
    *   **重置模拟**：将场景恢复到初始状态。
    *   **模拟速度调整**：允许用户加快或减慢模拟的播放速度。
*   **受力分析可视化**：
    *   在特定模式下（例如，选中实体并开启受力分析），系统能够以箭头的形式在实体上实时绘制其受到的各种力。
    *   箭头的方向表示力的方向，长度（或标签）表示力的大小。
    *   可显示的力包括：重力、弹簧力、绳子拉力、杆的支持力/拉力、碰撞产生的法向支持力和切向摩擦力等。
*   **场景管理与预设**：
    *   **保存/加载场景**：用户可以将当前构建的场景（包括所有实体、组件及其状态）保存到文件（通常为 JSON 格式，由 [`SceneSerializer`](physi_sim/scene/scene_serializer.py:1) 处理），并能从文件加载场景。
    *   **预设场景**：项目内置一些预设场景 ([`physi_sim/assets/presets/`](physi_sim/assets/presets/))，方便用户快速开始体验或作为学习示例。

### 6. Python脚本化事件 (初步支持)

*   **脚本引擎集成**：项目初步集成了 Python 脚本引擎 ([`ScriptEngine`](physi_sim/scripting/script_engine.py:1))。
*   **目的与潜力**：
    *   允许高级用户通过编写 Python 脚本来定义和触发场景中的特定事件和行为。
    *   例如，可以编写脚本实现：“当物体A的速度超过某个阈值时，改变物体B的颜色”或“每隔5秒在特定位置创建一个新物体”。
    *   为未来实现更复杂的用户自定义逻辑、游戏规则、自动化测试场景或与外部系统交互奠定基础。
*   **系统API (`SystemAPI`)**：脚本引擎可能会提供一个 `SystemAPI`，允许脚本访问和修改场景中的实体和组件数据，或者调用系统的某些功能。
*   **当前阶段**：此功能尚处于初步阶段，完整的事件规则系统和更友好的脚本编辑/管理界面是后续的开发目标。

## 技术栈

*   **主要编程语言**：Python (3.8+)
*   **图形用户界面 (GUI)**：PySide6 (官方 Qt for Python 库)
*   **数值计算 (可能)**：NumPy (如果项目中广泛用于向量和矩阵运算，则应提及)
*   **数据序列化**：JSON (用于场景文件的保存和加载)

## 如何运行

### 1. 环境准备

*   **Python 安装**：确保您的系统已安装 Python，推荐版本为 3.8 或更高。您可以从 [python.org](https://www.python.org/) 下载并安装。
*   **PySide6 安装**：PhysiSim 使用 PySide6 作为其 GUI 框架。打开您的终端或命令提示符，使用 pip 安装：
    ```bash
    pip install pyside6
    ```
*   **(可选) NumPy 安装**：如果项目依赖 NumPy 进行数学运算，也请安装它：
    ```bash
    pip install numpy
    ```
*   **获取项目代码**：
    *   **通过 Git 克隆** (推荐)：
        ```bash
        git clone <repository_url> # 替换为项目的实际 Git 仓库 URL
        cd physi_sim_project_directory # 进入项目根目录
        ```
    *   **下载 ZIP 包**：从项目主页下载 ZIP 压缩包并解压到本地。

### 2. 运行项目

1.  打开终端或命令提示符。
2.  导航到 PhysiSim 项目的根目录（即包含 `physi_sim` 子目录的目录）。
3.  执行以下命令启动应用程序：
    ```bash
    python physi_sim/main.py
    ```
    或者，如果您的 Python 安装配置了 `python3` 命令：
    ```bash
    python3 physi_sim/main.py
    ```

### 常见问题与故障排除

*   **`ModuleNotFoundError: No module named 'PySide6'`**：表示 PySide6 未正确安装或未安装在当前 Python 环境中。请确保已执行 `pip install pyside6` 并在正确的 Python 环境下运行。
*   **Python 版本不兼容**：如果遇到语法错误或与版本相关的其他问题，请检查您的 Python 版本是否符合项目要求。
*   **依赖库冲突**：在复杂的 Python 环境中，可能会遇到库版本冲突。考虑使用虚拟环境（如 `venv` 或 `conda`）来隔离项目依赖。

## 项目结构概述

PhysiSim 的代码库组织结构清晰，主要模块及其职责如下：

*   `physi_sim/`
    *   `main.py`: ([`physi_sim/main.py`](physi_sim/main.py:1)) 应用程序的入口点，负责初始化和启动主窗口及核心系统。
    *   `core/`: 包含项目的核心基础设施和通用工具。
        *   `entity_manager.py`: ([`physi_sim/core/entity_manager.py`](physi_sim/core/entity_manager.py:1)) 管理所有实体（Entity）的创建、销毁和查询。
        *   `component.py`: ([`physi_sim/core/component.py`](physi_sim/core/component.py:1)) 定义了组件基类以及各种具体的数据组件（如 `TransformComponent`, `PhysicsComponent`, `RenderComponent` 等）。
        *   `system.py`: ([`physi_sim/core/system.py`](physi_sim/core/system.py:1)) 定义了系统基类，所有处理实体行为的逻辑系统都继承自它。
        *   `vector.py`: ([`physi_sim/core/vector.py`](physi_sim/core/vector.py:1)) 提供二维向量运算支持。
        *   `utils.py`: ([`physi_sim/core/utils.py`](physi_sim/core/utils.py:1)) 包含一些通用的辅助函数和枚举类型。
    *   `physics/`: 物理引擎的核心实现。
        *   `physics_system.py`: ([`physi_sim/physics/physics_system.py`](physi_sim/physics/physics_system.py:1)) 主要的物理更新系统，负责应用力、积分运动、处理动力学。
        *   `collision_system.py`: ([`physi_sim/physics/collision_system.py`](physi_sim/physics/collision_system.py:1)) 负责检测实体间的碰撞，并生成碰撞信息。
        *   `constraint_solver.py`: ([`physi_sim/physics/constraint_solver.py`](physi_sim/physics/constraint_solver.py:1)) (或类似模块) 负责求解和应用各种约束（如接触约束、连接器约束）。
        *   `spring_system.py`, `rope_system.py`, `rod_system.py` (如果分离)：专门处理特定连接器逻辑的系统。
        *   `force_calculator.py`: ([`physi_sim/physics/force_calculator.py`](physi_sim/physics/force_calculator.py:1)) (可能存在) 用于计算各种作用力（如重力、阻力等）。
    *   `graphics/`: 图形用户界面 (GUI) 和渲染相关的代码。
        *   `main_window.py`: ([`physi_sim/graphics/main_window.py`](physi_sim/graphics/main_window.py:1)) 定义了应用程序的主窗口布局、菜单栏、工具栏和核心视图区域。
        *   `renderer_system.py`: ([`physi_sim/graphics/renderer_system.py`](physi_sim/graphics/renderer_system.py:1)) 负责将场景中的实体绘制到屏幕上，处理视图变换（平移、缩放）。
        *   `property_panel.py`: ([`physi_sim/graphics/property_panel.py`](physi_sim/graphics/property_panel.py:1)) 实现属性编辑面板，用于显示和修改选中实体的属性。
        *   `drawing_tools/`: 包含各种绘图和交互工具的处理器 (Handlers)，例如 [`RectangleToolHandler`](physi_sim/graphics/drawing_tools/rectangle_tool_handler.py:1), [`SelectToolHandler`](physi_sim/graphics/drawing_tools/select_tool_handler.py:1) 等，它们处理特定工具激活时的鼠标和键盘输入。
        *   `ui_handlers/`: 包含处理特定UI交互逻辑的模块，如场景文件操作 ([`SceneFileHandler`](physi_sim/graphics/ui_handlers/scene_file_handler.py:1))、模拟控制 ([`SimulationControlHandler`](physi_sim/graphics/ui_handlers/simulation_control_handler.py:1))、视图控制 ([`ViewControlHandler`](physi_sim/graphics/ui_handlers/view_control_handler.py:1))。
    *   `scene/`: 场景管理和序列化。
        *   `scene_manager.py`: ([`physi_sim/scene/scene_manager.py`](physi_sim/scene/scene_manager.py:1)) 负责管理当前活动场景，包括加载、卸载场景，以及场景内实体的组织。
        *   `scene_serializer.py`: ([`physi_sim/scene/scene_serializer.py`](physi_sim/scene/scene_serializer.py:1)) 实现场景数据的序列化（保存到文件）和反序列化（从文件加载）。
    *   `scripting/`: Python 脚本支持。
        *   `script_engine.py`: ([`physi_sim/scripting/script_engine.py`](physi_sim/scripting/script_engine.py:1)) 初步的 Python 脚本执行引擎，可能包含用于脚本与主程序交互的 API 定义。
    *   `assets/`: 存放静态资源。
        *   `presets/`: ([`physi_sim/assets/presets/`](physi_sim/assets/presets/)) 包含预设的场景文件 (JSON格式)，用于演示或快速启动。
        *   (可能还有图标、图像等其他资源)

## 当前状态与后续步骤

PhysiSim 目前已成功实现了其核心功能集，为用户提供了一个功能相对完备的二维物理模拟环境。这包括了灵活的图形化场景构建工具，基于 ECS 的健壮架构，精确的物理模拟核心（涵盖动力学、碰撞检测与响应、多种连接器及其约束处理），以及一套丰富且用户友好的高级 GUI 交互特性。初步的 Python 脚本化事件支持也已集成，为未来的扩展性打下了基础。

**后续主要开发方向与计划**：

1.  **完善用户事件规则系统**：
    *   **目标**：允许用户通过更直观、更强大的方式定义复杂的事件触发条件和响应动作，而不仅仅依赖于直接编写 Python 脚本。
    *   **可能的功能**：
        *   图形化的事件编辑器或基于简单逻辑块的规则构建器。
        *   例如，用户可以定义规则：“当实体A（类型：球）与实体B（类型：墙）发生碰撞时，并且实体A的速度大于X，则播放声音S，并使实体A的颜色变为红色。”
        *   支持更广泛的事件类型（如时间事件、键盘/鼠标输入事件、属性变化事件等）。
        *   提供更丰富的动作库（如创建/销毁实体、修改实体属性、施加力、播放动画/声音等）。
2.  **性能优化**：
    *   针对大规模场景（大量实体和复杂交互）进行性能分析和优化。
    *   探索空间分区算法（如四叉树）以加速碰撞检测。
    *   优化渲染管线。
3.  **扩展物理特性与组件**：
    *   引入更多类型的物理组件，如流体、软体、旋转关节等。
    *   增强现有组件的功能，例如更复杂的摩擦模型。
4.  **增强GUI与用户体验**：
    *   改进工具的易用性和交互反馈。
    *   提供更详细的撤销/重做功能。
    *   完善主题和自定义选项。
5.  **文档与教程**：
    *   编写更全面的用户手册和开发者文档。
    *   创建视频教程和示例项目，帮助用户快速上手。
6.  **社区与贡献**：
    *   建立社区支持渠道（如论坛、Discord服务器）。
    *   制定贡献指南，鼓励社区参与开发。

我们相信，通过持续的迭代和社区的共同努力，PhysiSim 将成为一个更加强大和受欢迎的物理模拟工具。

